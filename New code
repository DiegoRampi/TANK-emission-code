%% Prova 18: Implementazione flux limiter con dati Diesel
clear;
clc;


global  M R_gas k D cp_G mu_G cpL h_L rho_liq DeltaH_evap H_c TL A_ant B_ant C_ant NumbersSpatialDiscretisation t_riempimento t_riposo t_svuotamento cycle_duration
%% inputs 

T_t = 328;  %268,283,288,298,328

%% Parametri del serbatoio e costanti fisiche
H = 15; % Altezza del serbatoio (m)
diametro = H; % Diametro del serbatoio (m)
V_serbatoio = pi * (diametro / 2)^2 * (H-1); % Volume del serbatoio (m^3)
P = 1e5; % Pressione in Pa

%% Costanti Diesel
M = 0.14; % Massa molare del Diesel in kg/mol
R_gas = 8.314; % Costante dei gas perfetti in J/(mol*K)
k = 0.025; % Conducibilità termica dell'aria in W/m·K
D = 10^(-5); % Diffusività in m²/s
cp_G = 2100; % Calore specifico in J/kg·K
mu_G = 1.85e-5; % Viscosità dinamica dell'aria (Pa·s)
cpL = 2200; % Calore specifico Diesel liquido in J/kg·K
h_L = 12; % Coefficiente scambio termico del liquido W/m²·K
rho_liq = 835; % Densità del Diesel liquido a 298 K in kg/m³
DeltaH_evap = 375000*M; % Calore latente di evaporazione in J/mol
H_c = 0; % Costante di Henry NON UTILIZZATA
TL = 283; % Temperatura liquido in K

%% Costanti Antoine (per tensione di vapore)
A_ant = 12.101;
B_ant = 8907;
C_ant =0;


%% Parametri discretizzazione
NumbersSpatialDiscretisation = 50; % Numero di nodi spaziali


%% Condizioni iniziali
T_init = T_t * ones(NumbersSpatialDiscretisation, 1); % Temperatura iniziale uniforme (K)
C_init = 0.16*ones(NumbersSpatialDiscretisation,1);
%C_init = linspace(0.02, 0.01, NumbersSpatialDiscretisation)'; % Gradiente iniziale della concentrazione
y0 = [C_init; T_init]; % Condizioni iniziali combinate

%% Parametri per i cicli di riempimento, riposo e svuotamento
t_riempimento = 24 * 3600; % 24 ore
t_riposo = 1 * 24 * 3600; % 5 giorni di riposo
t_svuotamento = 24 * 3600; % 24 ore di svuotamento
cycle_duration = t_riempimento + t_riposo + t_svuotamento;
transition_time = 3600; % Tempo di transizione (1 ora)

%% Funzione per calcolare v_avg
v_avg_func = @(t) v_cicli(t, V_serbatoio, diametro, t_riempimento, t_riposo, t_svuotamento, cycle_duration, transition_time);

%% Definizione dei parametri extra da passare
params = {NumbersSpatialDiscretisation, D, k, cp_G, mu_G, diametro, v_avg_func, P, M, R_gas, h_L, rho_liq, cpL, DeltaH_evap, A_ant, B_ant, C_ant, H, H_c,V_serbatoio, t_riempimento, t_riposo, t_svuotamento, cycle_duration, transition_time,TL,T_t};

%% Matrice di massa (per condizioni al contorno)
mass_matrix = eye(2 * NumbersSpatialDiscretisation);
mass_matrix(1, 1) = 0;
mass_matrix(NumbersSpatialDiscretisation, NumbersSpatialDiscretisation) = 0;
mass_matrix(NumbersSpatialDiscretisation + 1, NumbersSpatialDiscretisation + 1) = 0;
mass_matrix(2 * NumbersSpatialDiscretisation, 2 * NumbersSpatialDiscretisation) = 0;


t_span = [0,cycle_duration*30]

%% Risoluzione del sistema tramite ode15s per ogni intervallo temporale

Output = OdeCompiler(t_span, params{:},mass_matrix,y0);

t = Output(:,1);

u_sol = Output(2:end,:);




%% FCN with time related jumps

function out = OdeCompiler(t_span, ~, ~, ~, ~, ~, diametro, ~, P, ~, ~, ~, ~, ~, ~, ~, ~, ~, H, ~,V_serbatoio, ~, ~, ~, ~, ~,~,T_t,~,~)

global  M R_gas k D cp_G mu_G cpL h_L rho_liq DeltaH_evap H_c TL A_ant B_ant C_ant NumbersSpatialDiscretisation t_riempimento t_riposo t_svuotamento cycle_duration



%% Parametri discretizzazione

y = linspace(0,1,NumbersSpatialDiscretisation);


%% Condizioni iniziali
T_init = TL * ones(NumbersSpatialDiscretisation, 1); % Temperatura iniziale uniforme (K)

T_init(NumbersSpatialDiscretisation) = T_t;
C_init = 0.01*ones(NumbersSpatialDiscretisation,1);
%C_init = linspace(0.02, 0.01, NumbersSpatialDiscretisation)'; % Gradiente iniziale della concentrazione
y0 = [C_init; T_init]; % Condizioni iniziali combinate

%% Parametri per i cicli di riempimento, riposo e svuotamento
t_riempimento = 12 * 3600; % 12 ore
t_riposo = 10 * 24 * 3600; % 7 giorni di riposo
t_svuotamento = 20*24 * 3600; % 24 ore di svuotamento
cycle_duration = t_riempimento + t_riposo + t_svuotamento+t_riposo/30;
transition_time = 3600; % Tempo di transizione (1 ora)

%% Funzione per calcolare v_avg
v_avg_func = @(t) v_cicli(t, V_serbatoio, diametro, t_riempimento, t_riposo, t_svuotamento, cycle_duration, transition_time);

%% Definizione dei parametri extra da passare
params = {NumbersSpatialDiscretisation, D, k, cp_G, mu_G, diametro, v_avg_func, P, M, R_gas, h_L, rho_liq, cpL, DeltaH_evap, A_ant, B_ant, C_ant, H, H_c,V_serbatoio, t_riempimento, t_riposo, t_svuotamento, cycle_duration, transition_time,TL,T_t};

%% Matrice di massa (per condizioni al contorno)
mass_matrix = eye(2 * NumbersSpatialDiscretisation);
mass_matrix(1, 1) = 0;
mass_matrix(NumbersSpatialDiscretisation, NumbersSpatialDiscretisation) = 0;
mass_matrix(NumbersSpatialDiscretisation + 1, NumbersSpatialDiscretisation + 1) = 0;
mass_matrix(2 * NumbersSpatialDiscretisation, 2 * NumbersSpatialDiscretisation) = 0;


%compilazione del vettore tempo dividendolo in range con velocità del
%fluido costante per evitare cambi improvvisi durente la risoluzione ODE


NumberOfCycles = ceil(t_span(2)/cycle_duration);


Time_vector = zeros(NumberOfCycles*3+1,1);

for i = 0: (NumberOfCycles-1)

    Time_vector(i*3+2) = cycle_duration*i + t_riempimento;
    Time_vector(i*3+3) = cycle_duration*i + t_riempimento + t_riposo;
    Time_vector(i*3+4) = cycle_duration*i + t_riempimento + t_riposo +  t_svuotamento;

end

v_riempimento = V_serbatoio / (pi * (diametro / 2)^2 * t_riempimento);
v_svuotamento = -0.3*V_serbatoio / (pi * (diametro / 2)^2 * t_svuotamento);




timeSolution_vector = zeros(1,1);

Solution_vector = zeros(2,NumbersSpatialDiscretisation);

% calcolo velocità del fluido

for i = 2 : length(Time_vector)

    cycle_time = mod(Time_vector(i), cycle_duration+0.001);

    if cycle_time <= t_riempimento
        v_avg = v_riempimento;
    elseif cycle_time <= (t_riempimento + t_riposo)
        v_avg = 0;
    else
        v_avg = v_svuotamento;
    end

    % parametri ODE

    params = {NumbersSpatialDiscretisation, D, k, cp_G, mu_G, diametro, v_avg_func, P, M, R_gas, h_L, rho_liq, cpL, DeltaH_evap, A_ant, B_ant, C_ant, H, H_c,V_serbatoio, t_riempimento, t_riposo, t_svuotamento, cycle_duration, transition_time,TL,T_t,v_avg};

    tic 

       % Define options for ode15s
opts = odeset('RelTol', 1e-10, 'AbsTol', 1e-10, 'Mass', mass_matrix, 'MassSingular', 'yes');
    
     if i > 2
        disp(i)
        pde_fun(t(end), u_sol(end,:)', params{:});
    else
     end



% Solve the DAE system
[t, u_sol] = ode15s(@(t, u) pde_fun(t, u, params{:}), t_span, y0, opts);

% Post-process the solution if needed

    toc

    if i == 2
        Solution_vector = u_sol;
        timeSolution_vector = t;

    else
        Solution_vector = [Solution_vector; u_sol];
        timeSolution_vector = [timeSolution_vector;t];
    end

    y0 = u_sol(end,:)';

    
     pde_fun(t(1), u_sol(1,:)', params{:});

end



out = [timeSolution_vector,Solution_vector];

figure(1)

plot(timeSolution_vector/3600,Solution_vector(:,NumbersSpatialDiscretisation))
title('Andamento Ctop nel tempo')
xlabel('tempo [h]')
ylabel('Ctop [mol/m3]')

figure(2)

plot(y,Solution_vector(2000,1:NumbersSpatialDiscretisation))
title('Andamento C nello spazio')
xlabel('y[-]')
ylabel('C [mol/m3]')

figure(3)

plot(y,Solution_vector(2000,NumbersSpatialDiscretisation+1:2*NumbersSpatialDiscretisation))
title('Andamento T nello spazio')
xlabel('y[-]')
ylabel('T [K]')

figure(4)
surf(y,timeSolution_vector/3600,Solution_vector(:,1:NumbersSpatialDiscretisation))
title('grafico 3D C')
xlabel('y[-]')
ylabel('tempo [h]')
zlabel('C [mol/m3]')

figure(5)
surf(y,timeSolution_vector/3600,Solution_vector(:,NumbersSpatialDiscretisation+1:2*NumbersSpatialDiscretisation))
title('grafico 3D T')
xlabel('y[-]')
ylabel('tempo [h]')
zlabel('T [K]')



pde_fun(timeSolution_vector(1), Solution_vector(1,:),params{:});

end


%%funzione PDE

function Output_array = pde_fun(t, u, NumbersSpatialDiscretisation, D, k_G, cp_G, mu_G, diametro, ~, P, M, R_gas, ~, ~, ~, ~, A_ant, B_ant, C_ant, H, ~,~, t_riempimento, t_riposo, ~, cycle_duration, ~,TL,T_t,v_avg)
    % Adaptation in time for solver stability during filling and emptying
    number_cycles = floor(t / cycle_duration);

    if v_avg < 0
        t = t - (t_riempimento + t_riposo) * number_cycles;
    elseif v_avg > 0
        t = t - cycle_duration * number_cycles;
    end

    % Receiving input
    Concentration_array = u(1:NumbersSpatialDiscretisation);
    Temperature_array = u((NumbersSpatialDiscretisation + 1):(2 * NumbersSpatialDiscretisation));

    % Spatial derivative discretization
    dTdy = zeros(NumbersSpatialDiscretisation, 1);
    d2Tdy2 = zeros(NumbersSpatialDiscretisation, 1);
    dCdy = zeros(NumbersSpatialDiscretisation, 1);
    d2Cdy2 = zeros(NumbersSpatialDiscretisation, 1);

    dy = 1 / NumbersSpatialDiscretisation;
    y = linspace(0, 1, NumbersSpatialDiscretisation);

    for i = 2:(NumbersSpatialDiscretisation - 1)
        % Concentration derivative with flux limiter
        rC = (Concentration_array(i) - Concentration_array(i - 1)) / (Concentration_array(i + 1) - Concentration_array(i));
        limiterC = flux_limiter(rC, 'minmod');
        dCdy(i) = limiterC * (Concentration_array(i + 1) - Concentration_array(i)) / dy;

        % Temperature derivative with flux limiter
        rT = (Temperature_array(i) - Temperature_array(i - 1)) / (Temperature_array(i + 1) - Temperature_array(i));
        limiterT = flux_limiter(rT, 'minmod');
        dTdy(i) = limiterT * (Temperature_array(i + 1) - Temperature_array(i)) / dy;

        % Second derivatives using central difference
        d2Tdy2(i) = (Temperature_array(i + 1) - 2 * Temperature_array(i) + Temperature_array(i - 1)) / dy^2;
        d2Cdy2(i) = (Concentration_array(i + 1) - 2 * Concentration_array(i) + Concentration_array(i - 1)) / dy^2;
    end

    dCdy(1) = (Concentration_array(2) - Concentration_array(1)) / dy;
    dTdy(NumbersSpatialDiscretisation) = (Temperature_array(NumbersSpatialDiscretisation) - Temperature_array(NumbersSpatialDiscretisation - 1)) / dy;
    dCdy(NumbersSpatialDiscretisation) = (Concentration_array(NumbersSpatialDiscretisation) - Concentration_array(NumbersSpatialDiscretisation - 1)) / dy;

    % Raoult's law for saturation concentration assuming ideal gas
    SaturationConcentration = 6894.76 * exp(A_ant - B_ant / (1.8 * Temperature_array(1))) / P * P / (R_gas * Temperature_array(1));
    Interface_gasDensity = P / (R_gas * Temperature_array(1));

    % Define v*
    v_star = v_avg - (D / Interface_gasDensity) * dCdy(1);

    % Initialize iterative calculation for transport coefficients
    Speed_array = zeros(NumbersSpatialDiscretisation, 1);
    Gas_density = Speed_array;
    Re = Speed_array;
    Sc = Speed_array;
    Pe_m = Speed_array;
    Pe_t = Speed_array;
    E_m = Speed_array;
    E_t = Speed_array;
    alfa = Speed_array;

    Gas_density(1) = Interface_gasDensity;
    SpeedPreviousIteration = v_star;
    LowerLimit = SpeedPreviousIteration / 5;

    % Upper limit calculations
    UpperLimit = SpeedPreviousIteration * 5;
    Re(1) = UpperLimit * diametro * Gas_density(1) / mu_G;
    Re(1) = abs(Re(1));
    Pr = mu_G * cp_G / k_G;
    Sc(1) = mu_G / (Gas_density(1) * M * D);
    Pe_m(1) = (1 / (Re(1) * Sc(1)) + (Re(1) * Sc(1)) / 192);
    Pe_t(1) = (1 / (Re(1) * Pr) + (Re(1) * Pr) / 192);
    E_m(1) = Pe_m(1) * D;
    E_t(1) = Pe_t(1) * k_G / (Gas_density(1) * M * cp_G);
    alfa(1) = E_t(1) / Interface_gasDensity / cp_G;

    % Initialize delta_Speed_LL
    delta_Speed_LL = -inf;

    % Bisection method for true vapor speed at the interface
    Speed_array(1) = LowerLimit + (UpperLimit - LowerLimit) / 2;
    delta_Speed = Speed_array(1) - (v_star + alfa(1) / Temperature_array(1) * (dTdy(1) - dTdy(end)));

    itCount = 0;
    while abs(delta_Speed) / abs(Speed_array(1)) > 1e-3 && itCount < 100
        itCount = itCount + 1;
        Speed_array(1) = LowerLimit + (UpperLimit - LowerLimit) / 2;
        Re(1) = Speed_array(1) * diametro * Gas_density(1) / mu_G;
        Re(1) = abs(Re(1));
        Sc(1) = mu_G / (Gas_density(1) * M * D);
        Pe_m(1) = (1 / (Re(1) * Sc(1)) + (Re(1) * Sc(1)) / 192);
        Pe_t(1) = (1 / (Re(1) * Pr) + (Re(1) * Pr) / 192);
        E_m(1) = Pe_m(1) * D;
        E_t(1) = Pe_t(1) * k_G / (Gas_density(1) * M * cp_G);
        alfa(1) = E_t(1) / Interface_gasDensity / cp_G;
        delta_Speed = Speed_array(1) - (v_star + alfa(1) / Temperature_array(1) * (dTdy(1) - dTdy(end)));

        if delta_Speed * delta_Speed_LL < 0
            UpperLimit = Speed_array(1);
        else
            LowerLimit = Speed_array(1);
            delta_Speed_LL = delta_Speed;
        end
    end

    for i = 2:NumbersSpatialDiscretisation
        % Upper limit calculations
        Speed_UL = Speed_array(1) * 5;
        Gas_density(i) = P / (R_gas * (TL + T_t) / 2);
        Re(i) = Speed_UL * diametro * Gas_density(i) / mu_G;
        Re(i) = abs(Re(i));
        Sc(i) = mu_G / (Gas_density(i) * M * D);
        Pe_m(i) = (1 / (Re(i) * Sc(i)) + (Re(i) * Sc(i)) / 192);
        Pe_t(i) = (1 / (Re(i) * Pr) + (Re(i) * Pr) / 192);
        E_m(i) = Pe_m(i) * D;
        E_t(i) = Pe_t(i) * k_G / (Gas_density(1) * M * cp_G);
        alfa(i) = E_t(i) / Interface_gasDensity / cp_G;

        % Lower limit calculations
        Speed_LL = Speed_array(1) / 5;
        Gas_density(i) = P / (R_gas * Temperature_array(i));
        Re(i) = Speed_LL * diametro * Gas_density(i) / mu_G;
        Re(i) = abs(Re(i));
        Sc(i) = mu_G / (Gas_density(i) * M * D);
        Pe_m(i) = (1 / (Re(i) * Sc(i)) + (Re(i) * Sc(i)) / 192);
        Pe_t(i) = (1 / (Re(i) * Pr) + (Re(i) * Pr) / 192);
        E_m(i) = Pe_m(i) * D;
        E_t(i) = Pe_t(i) * k_G / (Gas_density(1) * M * cp_G);
        alfa(i) = E_t(i) / Interface_gasDensity / cp_G;

        delta_Speed_LL = Speed_LL - (v_star + alfa(i) / Temperature_array(i) * (dTdy(i) - dTdy(end)));

        % Bisection method for true speed at a given point
        Speed_array(i) = Speed_LL + (Speed_UL - Speed_LL) / 2;
        delta_Speed = Speed_array(i) - (v_star + alfa(i) / Temperature_array(i) * (dTdy(i) - dTdy(end)));

        itCount = 0;
        while abs(delta_Speed / Speed_array(1)) > 1e-3 && itCount < 100
            itCount = itCount + 1;
            Speed_array(i) = Speed_LL + (Speed_UL - Speed_LL) / 2;
            delta_Speed = Speed_array(i) - (v_star + alfa(i) / Temperature_array(i) * (dTdy(i) - dTdy(end)));

            if delta_Speed * delta_Speed_LL < 0
                Speed_UL = Speed_array(i);
            else
                Speed_LL = Speed_array(i);
                delta_Speed_LL = delta_Speed;
            end
        end
    end

    dTdt = zeros(NumbersSpatialDiscretisation, 1);
    dCdt = dTdt;

    for i = 2:(NumbersSpatialDiscretisation - 1)
        dTdt_i = (v_avg * y(i) + (v_star - v_avg)) / (v_avg * t - H) * dTdy(i) + (alfa(i) / (Temperature_array(1) * (v_avg * t - H)^2)) * (Temperature_array(i) * d2Tdy2(i) - dTdy(i)^2 + dTdy(1) * dTdy(i));
        dCdt_i = (v_avg * y(i) + (v_star - v_avg)) / (v_avg * t - H) * dCdy(i) + (E_m(i) / (v_avg * t - H)^2) * d2Cdy2(i) - alfa(i) / (Temperature_array(1) * (v_avg * t - H)^2) * (dCdy(i) * (dTdy(i) - dTdy(1)) + Concentration_array(i) * d2Tdy2(i));

        dTdt(i) = dTdt_i;
        dCdt(i) = dCdt_i;

        if Temperature_array(i) > Temperature_array(end) && dTdt_i > 0
            dTdt(i) = 0;
        end

        if Concentration_array(i) < 0 && dCdt_i < 0
            dCdt(i) = 0;
        end
    end

    if Speed_array(end) >= 0
        Concentration_array_end = Concentration_array(end - 1);
        Temperature_array_end = T_t;
    else
        Concentration_array_end = Concentration_array(end - 1) + Concentration_array(end) * Speed_array(end) * (H - v_avg * t) / E_m(end) * dy;
        Temperature_array_end = T_t;
    end

    Output_array = zeros(2 * NumbersSpatialDiscretisation, 1);
    Output_array(1) = Concentration_array(1) - SaturationConcentration;

    for i = 2:(NumbersSpatialDiscretisation - 1)
        Output_array(i) = dCdt(i);
    end

    Output_array(NumbersSpatialDiscretisation) = Concentration_array_end - Concentration_array(NumbersSpatialDiscretisation);
    Output_array(NumbersSpatialDiscretisation + 1) = TL - Temperature_array(1);

    for i = 2:(NumbersSpatialDiscretisation - 1)
        Output_array(NumbersSpatialDiscretisation + i) = dTdt(i);
    end

    Output_array(2 * NumbersSpatialDiscretisation) = Temperature_array_end - Temperature_array(end);
end

function phi = flux_limiter(r, method)
    switch method
        case 'minmod'
            phi = max(0, min(1, r));
        case 'superbee'
            phi = max(0, max(min(2 * r, 1), min(r, 2)));
        case 'vanleer'
            phi = (r + abs(r)) / (1 + abs(r));
        otherwise
            phi = 1;
    end
end





%% Funzione per calcolare v_avg durante i cicli
function v_avg = v_cicli(t, V_serbatoio, diametro, t_riempimento, t_riposo, t_svuotamento, cycle_duration)
v_riempimento = V_serbatoio / (pi * (diametro / 2)^2 * t_riempimento);
v_svuotamento = -V_serbatoio / (pi * (diametro / 2)^2 * t_svuotamento);

cycle_time = mod(t, cycle_duration);


if cycle_time <= t_riempimento
    v_avg = v_riempimento;
elseif cycle_time <= (t_riempimento + t_riposo)
    v_avg = 0;
else
    v_avg = v_svuotamento;
end
end
